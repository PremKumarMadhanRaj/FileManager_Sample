import { Event, EmitType, INotifyPropertyChanged } from '@syncfusion/ej2-base';
import { NotifyPropertyChanges, Property, addClass, removeClass } from '@syncfusion/ej2-base';
import { SignatureBase, beforeSaveEventArgs } from '../common/signature-base';
import { SignatureModel } from './signature-model';

/**
 * Signature component is a user interface to draw the Signature or Text. It provides supports for various
 * Background color, Stroke color and Background Image.
 * ```html
 * <canvas id="signature"></canvas>
 * ```
 * ```typescript
 * <script>
 *   let signatureObj: Signature = new Signature(null , "#signature");
 * </script>
 * ```
 */

@NotifyPropertyChanges
export class Signature extends SignatureBase implements INotifyPropertyChanged {

    /* Private variables */
    private dataContext: HTMLFormElement;

    /**
     * Defines the background color.
     *
     * @default '#ffffff'
     */
    @Property('#ffffff')
    public backgroundColor: string;

    /**
     * Defines the background image.
     *
     * @default null
     */
    @Property(null)
    public backgroundImage: string;

    /**
     * Defines class/multiple classes separated by a space in the Signature element.
     *
     * @default ''
     */
    @Property('')
    public cssClass: string;

    /**
     * Enable or disable the Signature, when set to false, interaction with Signature will be prevented.
     *
     * @default false
     */
    @Property(false)
    public disabled: boolean;

    /**
     * Enable or disable the read only of the Signature, when set to false, interaction with Signature will be prevented.
     *
     * @default false
     */
    @Property(false)
    public isReadOnly: boolean;

    /**
     * Enable or disable the background of the Signature when it saves, when set to false, interaction with Signature will be saved without the background.
     *
     * @default true
     */
    @Property(true)
    public saveWithBackground: boolean;

    /**
     * Defines the stroke color.
     *
     * @default '#000000'
     */
    @Property('#000000')
    public strokeColor: string;

    /**
     * Defines the minimum stroke width for signature.
     *
     * @default 0.5
     */
    @Property(0.5)
    public minStrokeWidth: number;

    /**
     * Defines the maximum stroke width for signature.
     *
     * @default 2
     */
    @Property(2)
    public maxStrokeWidth: number;

    /**
     * Defines the velocity for signing in the Signature.
     *
     * @default 0.7
     */
    @Property(0.7)
    public velocity: number;

    /**
     * Enable or disable persisting component's state between page reloads.
     *
     * @default false
     */
    @Property(false)
    public enablePersistence: boolean;

    /**
     * Triggers while saving the signature.
     *
     * @event beforeSave
     */
    @Event()
    public beforeSave: EmitType<beforeSaveEventArgs>;

    /**
     * Triggers while changing the signature content.
     *
     * @event change
     */
    @Event()
    public change: EmitType<MouseEvent>;

    /**
     * Triggers once the component rendering is completed.
     *
     * @event created
     */
    @Event()
    public created: EmitType<MouseEvent>;

    /**
     * Constructor for creating the widget.
     *
     * @param {SignatureModel} options - Specifies the Signature model.
     * @param {string | HTMLFormElement} element - Specifies the element.
     * @private
     */
    constructor(options?: SignatureModel, element?: string | HTMLFormElement) {
        super(options, <HTMLFormElement | string> element);
    }

    protected preRender(): void {
        // pre render code snippets
    }

    /**
     * To Initialize the component rendering
     *
     * @private
     * @returns {void}
     */
    protected render(): void {
        this.initialize();
    }

    public initialize(): void {
        addClass([this.element], 'e-' + this.getModuleName());
        if (this.cssClass) {
            addClass([this.element], this.cssClass.split(' '));
        }
        const canvasEle: HTMLFormElement = this.element as HTMLFormElement;
        this.dataContext = canvasEle.getContext('2d');
        super.initialize(this.element);
        if (this.enablePersistence) {
            this.loadPersistedSignature();
        }
    }

    /**
     * To get the signature as Base 64.
     *
     * @returns {string}.
     */

    public getSignature(): string {
        return this.dataContext.canvas.toDataURL('image/png');
    }

    /**
     * To get component name.
     *
     * @returns {string} - Module Name
     * @private
     */
    protected getModuleName(): string {
        return 'signature';
    }

    /**
     * To get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Persist data
     */
    protected getPersistData(): string {
        return this.addOnPersist(['signatureValue']);
    }

    /**
     * Called internally if any of the property value changed.
     *
     * @param  {SignatureModel} newProp - Specifies new properties
     * @param  {SignatureModel} oldProp - Specifies old properties
     * @returns {void}
     * @private
     */
    public onPropertyChanged(newProp: SignatureModel, oldProp: SignatureModel): void {
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
            case 'backgroundColor':
                super.propertyChanged(prop, newProp.backgroundColor);
                break;
            case 'backgroundImage':
                super.propertyChanged(prop, newProp.backgroundImage);
                break;
            case 'cssClass':
                if (oldProp.cssClass) {
                    removeClass([this.element], oldProp.cssClass.split(' '));
                }
                if (newProp.cssClass) {
                    addClass([this.element], newProp.cssClass.split(' '));
                }
                break;
            case 'strokeColor':
                if (newProp.strokeColor !== oldProp.strokeColor) {
                    super.propertyChanged(prop, newProp.strokeColor);
                }
                break;
            case 'isReadOnly':
                super.propertyChanged(prop, newProp.isReadOnly);
                break;
            case 'disabled':
                super.propertyChanged(prop, newProp.disabled);
                break;
            }
        }
    }
}
