import { Component, INotifyPropertyChanged, Property } from '@syncfusion/ej2-base';
import { NotifyPropertyChanges, EventHandler, isNullOrUndefined } from '@syncfusion/ej2-base';
import { SignatureModel } from './../signature';

@NotifyPropertyChanges
export abstract class SignatureBase extends Component<HTMLFormElement> implements INotifyPropertyChanged {
    /* Private variables */
    private clientX: number;
    private clientY: number;
    /* time of the current point(x,y) of the corrdinates*/
    private time: number;
    private startPoint: Point;
    private controlPoint1 : Point;
    private controlPoint2 : Point;
    private endPoint : Point;
    private pointColl: Point[];
    private canvasContext: HTMLFormElement;
    private lastVelocity: number;
    private lastWidth: number;
    private incStep: number;
    private snapColl: string[];
    private minDistance: number = 5;
    private previous: number = 0;
    private interval: number = 30;
    private timeout: number | null = null;
    private storedArgs: MouseEvent & TouchEvent;
    private isSignatureEmpty: boolean = true;
    private signatureValue: string = '';

    /**
     * Defines the background color.
     *
     */
    public backgroundColor: string;

    /**
     * Defines the background image.
     *
     */
    public backgroundImage: string;

    /**
     * Enable or disable the Signature, when set to false, interaction with Signature will be prevented.
     *
     */
    public disabled: boolean;

    /**
     * Enable or disable the read only of the Signature, when set to false, interaction with Signature will be prevented.
     *
     */
    public isReadOnly: boolean;

    /**
     * Enable or disable the background of the Signature when it saves, when set to false, interaction with Signature will be saved without the background.
     *
     */
    public saveWithBackground: boolean;

    /**
     * Defines the stroke color.
     *
     */
    public strokeColor: string;

    /**
     * Defines the minimum stroke width for signature.
     *
     */
    public minStrokeWidth: number;

    /**
     * Defines the maximum stroke width for signature.
     *
     */
    public maxStrokeWidth: number;

    /**
     * Defines the velocity for signing in the Signature.
     *
     */
    public velocity: number;

    /**
     * To Initialize the component rendering
     *
     * @param {HTMLFormElement} element - Specifies the canvas element.
     * @param {parameter} parameter - Specifies only for the blazor parameter.
     * @returns {void}
     */
    public initialize(element: HTMLFormElement, parameter?: parameter): void {
        this.element = element;
        this.canvasContext = this.element.getContext('2d');
        if (parameter) {
            this.setBlazorParameter(parameter);
        }
        this.setHTMLProperties();
        if (!this.saveWithBackground) {
            this.updateSnapCollection();
        }
        this.wireEvents();
        this.trigger('created', this);
        this.isSignatureEmpty = true;
    }

    private setBlazorParameter(parameter: parameter): void {
        this.backgroundColor = parameter.backgroundColor || '#ffffff';
        this.backgroundImage = parameter.backgroundImage || null;
        this.disabled = parameter.disabled;
        this.isReadOnly = parameter.isReadOnly;
        this.maxStrokeWidth = parameter.maxStrokeWidth || 2;
        this.minStrokeWidth = parameter.minStrokeWidth || 0.5;
        this.velocity = 0.7;
        this.strokeColor = parameter.strokeColor || '#000000';
        this.saveWithBackground = parameter.saveWithBackground;
        this.signatureValue = parameter.signatureValue || '';
        this.interval = 30; this.minDistance = 5;
        this.previous = 0;
    }

    private wireEvents(): void {
        if (this.pointColl === undefined && !this.isReadOnly && !this.disabled) {
            EventHandler.add(this.canvasContext.canvas, 'mousedown touchstart', this.mouseDownHandler, this);
            EventHandler.add(document, 'keydown', this.keyboardHandler, this);
            window.addEventListener('resize', this.resizeHandler.bind(this));
        } else if (this.pointColl) {
            EventHandler.add(this.canvasContext.canvas, 'mousemove touchmove', this.mouseMoveHandler, this);
            EventHandler.add(this.canvasContext.canvas, 'mouseup touchend', this.mouseUpHandler, this);
        }
    }

    private unwireEvents(type: string): void {
        if (type === 'mouseup' || type === 'touchend') {
            EventHandler.remove(this.canvasContext.canvas, 'mousemove touchmove', this.mouseMoveHandler);
            EventHandler.remove(this.canvasContext.canvas, 'mouseup touchend', this.mouseUpHandler);
        } else {
            EventHandler.remove(this.canvasContext.canvas, 'mousedown touchstart', this.mouseDownHandler);
            EventHandler.remove(document, 'keydown', this.keyboardHandler);
            window.removeEventListener('resize', this.resizeHandler);
        }
    }

    private setHTMLProperties(): void {
        if (this.element.height === 150) {
            this.element.height = this.element.getBoundingClientRect().height;
        }
        if (this.element.width === 300) {
            this.element.width = this.element.getBoundingClientRect().width;
        }
        this.canvasContext.fillStyle = this.strokeColor;
        this.canvasContext.canvas.style.backgroundColor = this.backgroundColor;
        this.canvasContext.canvas.style.border = '1px solid grey';
        if (this.backgroundImage && !this.saveWithBackground) {
            this.canvasContext.canvas.style.backgroundImage = 'url(' +  this.backgroundImage + ')';
        }
        if (this.saveWithBackground) {
            if (this.backgroundImage) {
                this.saveBackground(this.backgroundImage);
            } else {
                this.setBackgroundColor(this.backgroundColor);
            }
        }
    }

    private mouseDownHandler(e : MouseEvent & TouchEvent): void {
        if (e.buttons === 1 || e.type === 'touchstart') {
            e.preventDefault();
            e.stopPropagation();
            this.beginStroke(e);
            this.wireEvents();
        }
    }

    private mouseMoveHandler(e: MouseEvent & TouchEvent): void {
        if ( e.buttons === 1 || e.type === 'touchmove') {
            e.preventDefault();
            e.stopPropagation();
            if (this.interval) {
                this.updateStrokeWithThrottle(e);
            } else {
                this.updateStroke(e);
            }
        }
    }

    private mouseUpHandler(e: MouseEvent & TouchEvent): void {
        e.preventDefault();
        e.stopPropagation();
        this.endDraw();
        this.updateSnapCollection();
        this.unwireEvents(e.type);
        this.trigger('change', this);
        this.signatureValue = this.snapColl[this.incStep];
    }

    private keyboardHandler(e : KeyboardEvent): void {
        const args: beforeSaveEventArgs = {fileName: 'Signature', type: 'png'};
        switch (e.keyCode) {
        case 46:
            this.clear();
            break;
        case (17 && 83):
            this.trigger('beforeSave', args, (observedChangeArgs: beforeSaveEventArgs) => {
                this.save(observedChangeArgs.type, observedChangeArgs.fileName);
            });
            e.preventDefault();
            e.stopImmediatePropagation();
            break;
        case (17 && 90):
            this.undo();
            break;
        case (17 && 89):
            this.redo();
            break;
        }
    }

    private resizeHandler(): void {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy: SignatureBase = this;
        const bitmapImage: HTMLImageElement = new Image();
        bitmapImage.onload = () => {
            Promise.all([
                createImageBitmap(bitmapImage, 0, 0, proxy.element.width, proxy.element.height)
            ]).then((results: ImageBitmap[]) => {
                proxy.canvasContext.drawImage(results[0], 0, 0, proxy.element.width, proxy.element.height);
            });
        };
        bitmapImage.src = this.snapColl[this.incStep];
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
    }

    private beginStroke(e : MouseEvent & TouchEvent): void {
        this.refresh();
        this.updateStroke(e);
    }

    private updateStroke(e : MouseEvent & TouchEvent): void {
        const point: Point = this.createPoint(e);
        this.addPoint(point);
    }

    private updateStrokeWithThrottle(args: MouseEvent & TouchEvent): void {
        const now: number = Date.now();
        const remaining: number = this.interval - (now - this.previous);
        this.storedArgs = args;
        if (remaining <= 0 || remaining > this.interval) {
            if (this.timeout) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
            this.previous = now;
            this.updateStroke(this.storedArgs);
            if (!this.timeout) {
                this.storedArgs = null;
            }
        } else if (!this.timeout) {
            this.timeout = window.setTimeout(this.delay.bind(this), remaining);
        }
    }

    private delay(): void {
        this.previous = Date.now();
        this.timeout = null;
        this.updateStroke(this.storedArgs);
        if (!this.timeout) {
            this.storedArgs = null;
        }
    }

    private createPoint(e: MouseEvent & TouchEvent): Point {
        const rect: HTMLFormElement = this.canvasContext.canvas.getBoundingClientRect();
        if (e.type === 'mousedown' || e.type === 'mousemove') {
            return this.point(e.clientX - rect.left, e.clientY - rect.top, new Date().getTime());
        } else {
            return this.point(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top, new Date().getTime());
        }
    }

    /* Returns the current point corrdinates(x, y) and time.*/
    private point(x1: number, y1: number, time1: number): Point {
        this.clientX = x1;
        this.clientY = y1;
        this.time = time1 || new Date().getTime();
        return { x: this.clientX, y: this.clientY, time: this.time };
    }

    private addPoint(point: Point): void {
        const points: Point[] = this.pointColl; let cp2: Point; let cp3: Point;
        const lastPoint: Point = points.length > 0 && points[points.length - 1];
        const isLastPointTooClose: boolean = lastPoint ? this.distanceTo(lastPoint) <= this.minDistance : false;
        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
            points.push(point);
            if (points.length > 2) {
                if (points.length === 3) {
                    points.unshift(points[0]);
                }
                cp2 = (this.calculateCurveControlPoints(points[0], points[1], points[2])).cp2;
                cp3 = (this.calculateCurveControlPoints(points[1], points[2], points[3])).cp1;
                this.startPoint = points[1]; this.controlPoint1 = cp2; this.controlPoint2 = cp3; this.endPoint = points[2];
                this.startDraw();
                points.shift();
            }
        }
    }

    private startDraw(): void {
        let velocity: number;
        velocity = this.pointVelocityCalc(this.startPoint);
        velocity = this.velocity * velocity + (1 - this.velocity) * this.lastVelocity;
        const newWidth: number = Math.max(this.maxStrokeWidth / (velocity + 1), this.minStrokeWidth);
        this.curveDraw(this.lastWidth, newWidth);
        this.lastVelocity = velocity;
        this.lastWidth = newWidth;
    }

    private endDraw(): void {
        const canDrawCurve: boolean = this.pointColl.length > 2; const point: Point = this.pointColl[0];
        if (!canDrawCurve && point) {
            this.strokeDraw(point);
        }
    }

    /* Calculate the Bezier (x, y) coordinate of the curve. */
    private curveDraw(startWidth: number, endWidth: number): void {
        const context: HTMLFormElement = this.canvasContext;
        let width: number; let i: number; let t1: number; let t2: number;
        let t3: number; let u1: number; let u2: number; let u3: number; let x: number; let y: number;
        const widthValue: number = endWidth - startWidth;
        const bezierLength: number = this.bezierLengthCalc();
        const drawSteps : number = Math.ceil(bezierLength) * 2;
        context.beginPath();
        for (i = 0; i < drawSteps; i++) {
            t1 = i / drawSteps; t2 = t1 * t1; t3 = t2 * t1;
            u1 = 1 - t1; u2 = u1 * u1; u3 = u2 * u1;
            x = u3 * this.startPoint.x; x += 3 * u2 * t1 * this.controlPoint1.x;
            x += 3 * u1 * t2 * this.controlPoint2.x; x += t3 * this.endPoint.x;
            y = u3 * this.startPoint.y; y += 3 * u2 * t1 * this.controlPoint1.y;
            y += 3 * u1 * t2 * this.controlPoint2.y; y += t3 * this.endPoint.y;
            width = Math.min(startWidth + t3 * widthValue, this.maxStrokeWidth);
            this.arcDraw(x, y, width);
        }
        context.closePath();
        context.fill();
        this.isSignatureEmpty = false;
    }

    private strokeDraw(point: Point): void {
        const context: HTMLFormElement = this.canvasContext;
        const pointSize: number = (this.minStrokeWidth + this.maxStrokeWidth) / 2;
        context.beginPath();
        this.arcDraw( point.x, point.y, pointSize);
        context.closePath();
        context.fill();
        this.isSignatureEmpty = false;
    }

    private arcDraw(x: number, y: number, size: number): void {
        const context: HTMLFormElement = this.canvasContext;
        context.moveTo(x, y);
        context.arc(x, y, size, 0, 2 * Math.PI, false);
    }

    /* Utility functions for Bezier algorithm*/
    private calculateCurveControlPoints(p1: Point, p2: Point, p3: Point): {cp1: Point, cp2: Point} {
        const dx1: number = p1.x - p2.x; const dy1: number = p1.y - p2.y;
        const dx2: number = p2.x - p3.x; const dy2: number = p2.y - p3.y;
        const m1: Point = { x: (p1.x + p2.x) / 2.0, y: (p1.y + p2.y) / 2.0 };
        const m2: Point = { x: (p2.x + p3.x) / 2.0, y: (p2.y + p3.y) / 2.0 };
        const l1: number = Math.sqrt(dx1 * dx1 + dy1 * dy1);
        const l2: number = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        const dxm: number = (m1.x - m2.x); const dym: number = (m1.y - m2.y);
        const k: number = l2 / (l1 + l2);
        const cm: Point = { x: m2.x + dxm * k, y: m2.y + dym * k };
        const tx: number = p2.x - cm.x; const ty: number = p2.y - cm.y;
        return {
            cp1: this.point(m1.x + tx, m1.y + ty, 0),
            cp2: this.point(m2.x + tx, m2.y + ty, 0)
        };
    }

    /* Returns approximated bezier length of the curuve.*/
    private bezierLengthCalc(): number {
        const steps: number = 10; let length: number = 0; let i: number; let t: number; let pointx1: number;
        let pointy1: number; let pointx2: number; let pointy2: number; let pointx3: number; let pointy3: number;
        for (i = 0; i <= steps; i++) {
            t = i / steps;
            pointx1 = this.bezierPointCalc(t, this.startPoint.x, this.controlPoint1.x, this.controlPoint2.x, this.endPoint.x);
            pointy1 = this.bezierPointCalc(t, this.startPoint.y, this.controlPoint1.y, this.controlPoint2.y, this.endPoint.y);
            if (i > 0) {
                pointx3 = pointx1 - pointx2;
                pointy3 = pointy1 - pointy2;
                length += Math.sqrt(pointx3 * pointx3 + pointy3 * pointy3);
            }
            pointx2 = pointx1;
            pointy2 = pointy1;
        }
        return length;
    }

    /* Calculate parametric value of x or y given t and the
       four point(startpoint, controlpoint1, controlpoint2, endpoint) coordinates of a cubic bezier curve.*/
    private bezierPointCalc(t: number, startpoint: number, cp1: number, cp2: number, endpoint: number): number {
        return startpoint * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * cp1 * (1.0 - t) * (1.0 - t) * t + 3.0 *
        cp2 * (1.0 - t) * t * t + endpoint * t * t * t;
    }

    /* Velocity between the current point and last point.*/
    private pointVelocityCalc(startPoint: Point): number {
        return (this.time !== startPoint.time) ? this.distanceTo(startPoint) / (this.time - startPoint.time) : 0;
    }

    /* Distance between the current point and last point.*/
    private distanceTo(start: Point): number {
        return Math.sqrt(Math.pow(this.clientX - start.x, 2) + Math.pow(this.clientY - start.y, 2));
    }

    private isRead(isRead: boolean): void {
        if (isRead) {
            EventHandler.remove(this.canvasContext.canvas, 'mousedown touchstart', this.mouseDownHandler);
        } else if (!this.disabled) {
            EventHandler.add(this.canvasContext.canvas, 'mousedown touchstart', this.mouseDownHandler, this);
        }
    }

    private enableDisable(isDisable: boolean): void {
        this.disabled = isDisable;
        if (isDisable) {
            this.canvasContext.canvas.classList.add('e-disabled');
            this.isRead(true);
        } else {
            this.canvasContext.canvas.classList.remove('e-disabled');
            this.isRead(false);
        }
    }

    private updateSnapCollection(): void {
        if (isNullOrUndefined(this.incStep)) {
            this.incStep = -1;
            this.incStep++;
            this.snapColl = [];
        }
        else {
            this.incStep++;
        }
        if (this.incStep < this.snapColl.length) {
            this.snapColl.length = this.incStep;
        }
        if (this.incStep > 0) {
            const canvasNew: HTMLFormElement = this.createElement('canvas', { className: 'e-' + this.getModuleName() + '-wrapper' });
            const canvasContextNew: HTMLFormElement = canvasNew.getContext('2d');
            canvasNew.width = this.canvasContext.canvas.width;
            canvasNew.height = this.canvasContext.canvas.height;
            canvasContextNew.drawImage(this.canvasContext.canvas, 0, 0, canvasNew.width, canvasNew.height);
            this.snapColl.push(canvasNew.toDataURL());
        } else {
            this.snapColl.push(this.canvasContext.canvas.toDataURL());
        }
    }

    private saveBackground(imageSrc: string): void {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy: SignatureBase = this;
        const imageObj: HTMLImageElement = new Image();
        imageObj.crossOrigin = 'anonymous';
        imageObj.src = imageSrc;
        imageObj.onload = () => {
            proxy.canvasContext.globalCompositeOperation = 'source-over';
            proxy.canvasContext.drawImage(imageObj, 0, 0, proxy.element.width, proxy.element.height);
            proxy.updateSnapCollection();
        };
        this.canvasContext.clearRect( 0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
    }

    private setBackgroundColor(color: string): void {
        const canvasEle: HTMLFormElement = this.canvasContext;
        canvasEle.strokeStyle = color;
        let i: number; let j: number;
        for ( i = 1; i <= canvasEle.canvas.width; i++) {
            for ( j = 1; j <= canvasEle.canvas.height; j++) {
                canvasEle.strokeRect( 0, 0, i, j);
            }
        }
        this.updateSnapCollection();
    }

    protected loadPersistedSignature(): void {
        if (this.signatureValue === '') {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy: SignatureBase = this;
        const lastImage: HTMLImageElement = new Image();
        lastImage.src = this.signatureValue;
        lastImage.onload = () => {
            proxy.canvasContext.clearRect(0, 0, proxy.element.width, proxy.element.height);
            proxy.canvasContext.drawImage(lastImage, 0, 0);
        };
        this.isSignatureEmpty = false;
    }

    /**
     * To get the signature as Blob.
     * @param {string} url - specify the url/base 64 string to get blob of the signature.
     * @returns {Blob}.
     */

    public getBlob(url: string): Blob {
        const arr: string[] = url.split(','); const type: string = arr[0].match(/:(.*?);/)[1];
        const bstr: string = atob(arr[1]); let n: number = bstr.length; const u8arr: Uint8Array = new Uint8Array(n);
        while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], { type: type });
    }

    private download(blob: Blob, fileName: string): void {
        const blobUrl: string = URL.createObjectURL(blob);
        const a: HTMLAnchorElement = document.createElement('a');
        a.href = blobUrl;
        a.target = '_parent';
        a.download = fileName;
        (document.body || document.documentElement).appendChild(a);
        a.click();
        a.parentNode.removeChild(a);
    }

    /**
     * To refresh the signature.
     *
     * @returns {void}.
     */
    public refresh(): void {
        this.pointColl = [];
        this.lastVelocity = 0;
        this.lastWidth = (this.minStrokeWidth + this.maxStrokeWidth) / 2;
    }

    /**
     * To clear the signature.
     *
     * @returns {void}.
     */

    public clear(): void {
        this.canvasContext.clearRect( 0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
        this.refresh();
        if (this.saveWithBackground) {
            if (this.backgroundImage) {
                this.saveBackground(this.backgroundImage);
            } else {
                this.setBackgroundColor(this.backgroundColor);
            }
        }
        this.trigger('change', this);
        this.isSignatureEmpty = true;
    }

    /**
     * To undo the last action.
     *
     * @returns {void}.
     */

    public undo(): void {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy: SignatureBase = this;
        if (this.incStep > 0) {
            this.incStep--;
            const undoImg: HTMLImageElement = new Image();
            undoImg.src = this.snapColl[this.incStep];
            undoImg.onload = () => {
                proxy.canvasContext.clearRect(0, 0, proxy.element.width, proxy.element.height);
                proxy.canvasContext.drawImage(undoImg, 0, 0);
            };
        }
        this.trigger('change', this);
    }

    /**
     * To redo the last action.
     *
     * @returns {void}.
     */
    public redo(): void {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy: SignatureBase = this;
        if (this.incStep < this.snapColl.length - 1) {
            this.incStep++;
            const redoImg: HTMLImageElement = new Image();
            redoImg.src = this.snapColl[this.incStep];
            redoImg.onload = () => {
                proxy.canvasContext.clearRect(0, 0, proxy.element.width, proxy.element.height);
                proxy.canvasContext.drawImage(redoImg, 0, 0);
            };
        }
        this.trigger('change', this);
    }

    /**
     * To check whether the signature is empty or not.
     *
     * @returns {boolean}.
     */

    public isEmpty(): boolean {
        return this.isSignatureEmpty;
    }

    /**
     * To check whether the undo collection is empty or not.
     *
     * @returns {boolean}.
     */

    public canUndo(): boolean {
        return this.incStep > 0;
    }

    /**
     * To check whether the redo collection is empty or not.
     *
     * @returns {boolean}.
     */

    public canRedo(): boolean {
        return this.incStep < this.snapColl.length - 1;
    }

    /**
     * To draw the signature based on the given text, with the font family and font size.
     *
     * @param {string} text - specify text to be drawn as signature.
     * @param {string} fontFamily - specify font family of a signature.
     * @param {number} fontSize - specify font size of a signature.
     *
     * @returns {void}.
     */

    public draw(text: string, fontFamily?: string, fontSize?: number): void {
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
        fontFamily = fontFamily || 'Arial';
        fontSize = fontSize || 30;
        this.canvasContext.font = fontSize + 'px ' + fontFamily;
        this.canvasContext.textAlign = 'center';
        this.canvasContext.textBaseline = 'middle';
        this.canvasContext.fillText(text, this.element.width / 2, this.element.height / 2);
        this.updateSnapCollection();
        this.isSignatureEmpty = false;
    }

    /**
     * To get the signature as Base 64.
     *
     * @returns {string}.
     */

    public getSignature(): string {
        return this.canvasContext.canvas.toDataURL('image/png');
    }

    /**
     * To load the signature with the given base 64 string, height and width.
     *
     * @param {string} signature - specify the url/base 64 string to be drawn as signature.
     * @param {number} width - specify the width of the loaded signature image.
     * @param {number} height - specify the height of the loaded signature image.
     * @returns {void}.
     */

    public load(signature: string, width?: number, height?: number): void {
        height = height || this.element.height;
        width = width || this.element.width;
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const proxy: SignatureBase = this;
        const bitmapImage: HTMLImageElement = new Image();
        this.canvasContext.clearRect(0, 0, this.canvasContext.canvas.width, this.canvasContext.canvas.height);
        bitmapImage.src = signature;
        bitmapImage.onload = () => {
            Promise.all([
                createImageBitmap(bitmapImage, 0, 0, width, height)
            ]).then((results: ImageBitmap[]) => {
                const tempCanvas: HTMLCanvasElement = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                tempCanvas.getContext('2d').drawImage(results[0], 0, 0);
                proxy.canvasContext.drawImage(tempCanvas, 0, 0, width, height, 0, 0, proxy.element.width, proxy.element.height);
            });
        };
        this.updateSnapCollection();
        this.isSignatureEmpty = false;
    }

    /**
     * To save the signature with the given type and file name.
     *
     * @param {string} type - specify type of the file to be saved a signature.
     * @param {string} fileName - specify name of the file to be saved a signature.
     *
     * @returns {void}.
     */

    public save(type?: string, fileName?: string): void {
        fileName = fileName || 'Signature';
        type = type || 'png';
        const dataURL: string = this.canvasContext.canvas.toDataURL('image/' + type);
        this.download(this.getBlob(dataURL), fileName + '.' + type);
    }

    /**
     * To save the signature as Blob.
     *
     * @returns {Blob}.
     */
    public saveAsBlob(): Blob {
        return this.getBlob(this.canvasContext.canvas.toDataURL('image/png'));
    }

    /**
     * Get component name.
     *
     * @returns {string} - Module Name
     * @private
     */
    protected getModuleName(): string {
        return 'signature';
    }

    /**
     * To get the properties to be maintained in the persisted state.
     *
     * @returns {string} - Persist data
     */
    protected getPersistData(): string {
        this.signatureValue = this.snapColl[this.incStep];
        return this.addOnPersist(['signatureValue']);
    }

    /**
     * Removes the component from the DOM and detaches all its related event handlers.
     * Also it maintains the initial input element from the DOM.
     *
     * @method destroy
     * @returns {void}
     */
    public destroy(): void {
        this.unwireEvents(null);
        super.destroy();
    }

    /**
     * Called internally if any of the property value changed.
     *
     * @param  {SignatureModel} newProp - Specifies new properties
     * @param  {SignatureModel} oldProp - Specifies old properties
     * @returns {void}
     * @private
     */
    public onPropertyChanged(newProp: SignatureModel, oldProp: SignatureModel): void {
        // On Property Changed
    }

    /**
     * Modified onPropertyChanged method for both blazor and EJ2 signature component.
     *
     * @param {string} key - Specifies the property, which changed.
     * @param {string} value - Specifies the property value changed.
     * @returns {void}
     */
    public propertyChanged(key: string, value: string | boolean): void {
        const canvasNew: HTMLFormElement = this.canvasContext;
        switch (key) {
        case 'backgroundColor':
            if (this.saveWithBackground) {
                this.setBackgroundColor(value as string);
            } else {
                canvasNew.canvas.style.backgroundColor = value;
            }
            break;
        case 'backgroundImage':
            if (this.saveWithBackground) {
                this.saveBackground(value as string);
            } else {
                canvasNew.canvas.style.backgroundImage = 'url(' + value + ')';
            }
            break;
        case 'strokeColor':
            canvasNew.fillStyle = value;
            break;
        case 'isReadOnly':
            this.isRead(value as boolean);
            break;
        case 'disabled':
            this.enableDisable(value as boolean);
            break;
        }
    }
}

/**
 * Interface for Point object.
 */
interface Point {
    /**
     * Specifies the x position of the point.
     */
    x: number;
    /**
     * Specifies the y position of the point.
     */
    y: number;
    /**
     * Specifies the time.
     */
    time?: number;
}

/**
 * Interface for before save the canvas as image.
 */
export interface beforeSaveEventArgs {
    /**
     * Specifies the filename of the image.
     */
    fileName?: string;
    /**
     * Specifies the file type 0f the image.
     */
    type?: string;
}

/**
 * Blazor parameter for signature component.
 */
export interface parameter {

    /**
     * Specifies the background color of the signature.
     */
    backgroundColor: string;

    /**
     * Specifies the background image of the signature.
     */
    backgroundImage: string;

    /**
     * Specifies the stroke color of the signature.
     */
    strokeColor: string;

    /**
     * To read only the signature can't draw.
     */
    isReadOnly: boolean;

    /**
     * Specifies the enable/disable of the signature.
     */
    disabled: boolean;

    /**
     * Specifies the signature save with background(color and image).
     */
    saveWithBackground: boolean;

    /**
     * Specifies minimum stroke width to draw signature.
     */
    minStrokeWidth: number;

    /**
     * Specifies maximum stroke width to draw signature.
     */
    maxStrokeWidth: number;

    /**
     * Specifies velocity of the stroke to draw signature.
     */
    velocity: number;

    /**
     * Specifies the last signature url to maintain the persist state.
     */
    signatureValue: string;
}
